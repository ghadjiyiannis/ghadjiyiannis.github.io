<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Software Engineering on George Hadjiyiannis</title>
    <link>https://ghadjiyiannis.github.io/categories/software-engineering/</link>
    <description>Recent content in Software Engineering on George Hadjiyiannis</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Tue, 24 Sep 2019 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://ghadjiyiannis.github.io/categories/software-engineering/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Data Trumps Opinion (every time)</title>
      <link>https://ghadjiyiannis.github.io/blog/data_trumps_opinion/</link>
      <pubDate>Tue, 24 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://ghadjiyiannis.github.io/blog/data_trumps_opinion/</guid>
      <description>Anyone who has worked for a successful B2C knows how much better and more precise decision making gets, once it is empowered by data. However, two of the companies I worked for turned this into an art, and one of the two is, in my eyes, the unquestioned champion. In fact, we had such detailed knowledge of our numbers (despite the many cyclicalities) that we would occasionally find software bugs through our revenue figures: someone would notice a small drop in revenue and track conversion through the user journey to eventually find a broken page.</description>
    </item>
    
    <item>
      <title>Software is hard - Part 2: Implicit Requirements</title>
      <link>https://ghadjiyiannis.github.io/blog/software_is_hard_implicit_requirements/</link>
      <pubDate>Tue, 02 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>https://ghadjiyiannis.github.io/blog/software_is_hard_implicit_requirements/</guid>
      <description>Every professional in the software industry knows that building software is a highly unpredictable business. This is why we don&amp;rsquo;t like the question of &amp;ldquo;How long is it going to take?&amp;rdquo;. The thing that always puzzled me, however, is that that unpredictability always seems to point in the wrong direction: software seems to almost always take longer to build than expected. With practically any other process, one would expect something similar to a normal (binomial) distribution around the expected estimate.</description>
    </item>
    
    <item>
      <title>Software is hard - Part 1: Scaling</title>
      <link>https://ghadjiyiannis.github.io/blog/software_is_hard_scaling/</link>
      <pubDate>Thu, 13 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://ghadjiyiannis.github.io/blog/software_is_hard_scaling/</guid>
      <description>A long time ago, when I was still in college, I was fortunate enough to take a Software Engineering class by Prof. John Guttag. I remember him starting one of the lectures with the question:
&amp;ldquo;Can anyone here write a 10,000 LOC program in a year?&amp;rdquo;
A large portion of the class raised their hands (this is MIT, after all). He then proceeded to ask:
&amp;ldquo;Can anyone here write a 100,000 LOC program in ten years?</description>
    </item>
    
  </channel>
</rss>